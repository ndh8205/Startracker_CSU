function rgb_img = bayer_to_rgb_cfa(bayer_img)
% BAYER_TO_RGB_CFA Bayer 패턴을 RGB로 변환 (FPGA cfa.cpp 알고리즘 재현)
%
% [설명]
%   이 함수는 FPGA에 구현된 CFA(Color Filter Array) 디모자이킹 알고리즘을
%   MATLAB으로 동일하게 재현한 것입니다.
%
%   Bayer 패턴 이미지 센서(OV4689)는 각 픽셀이 R, G, B 중 하나의 색만
%   감지합니다. 이 함수는 3x3 윈도우 기반 bilinear(쌍선형) 보간법을 사용하여
%   각 픽셀에서 누락된 색상 정보를 주변 픽셀로부터 복원합니다.
%
%   FPGA cfa.cpp의 Cfa2Rgb_operator() 함수와 동일한 보간 로직을 사용합니다.
%
% Bayer RGGB 패턴 배치 (OV4689 센서 기준):
%
%   열(col):  0     1     2     3     4     5   ...
%   행(row):
%     0     [ R  ][ Gr ][ R  ][ Gr ][ R  ][ Gr ] ...
%     1     [ Gb ][ B  ][ Gb ][ B  ][ Gb ][ B  ] ...
%     2     [ R  ][ Gr ][ R  ][ Gr ][ R  ][ Gr ] ...
%     3     [ Gb ][ B  ][ Gb ][ B  ][ Gb ][ B  ] ...
%     ...
%
%   여기서:
%     R  = Red 픽셀        (짝수행, 짝수열)
%     Gr = Green-Red 픽셀  (짝수행, 홀수열) - R행에 있는 Green
%     Gb = Green-Blue 픽셀 (홀수행, 짝수열) - B행에 있는 Green
%     B  = Blue 픽셀       (홀수행, 홀수열)
%
% pos_idx 계산 방식:
%   pos_idx = r_idx * 2 + c_idx
%   여기서 r_idx = mod(row-1, 2), c_idx = mod(col-1, 2)
%   (MATLAB은 1-based 인덱스이므로 row-1, col-1 사용)
%
%   FPGA cfa.cpp에서의 대응:
%     pos_idx[1] = r % 2   (행의 홀짝)
%     pos_idx[0] = c % 2   (열의 홀짝)
%     → pos_idx = {행 홀짝 비트, 열 홀짝 비트} (2비트 값: 0~3)
%
%   결과 매핑:
%     pos_idx = 0 → (짝수행, 짝수열) → R 위치
%     pos_idx = 1 → (짝수행, 홀수열) → Gr 위치
%     pos_idx = 2 → (홀수행, 짝수열) → Gb 위치
%     pos_idx = 3 → (홀수행, 홀수열) → B 위치
%
% [FPGA 원본 소스 경로]
%   reverse_engineering/recent/ssov_v700_20260128_ljc/ip_repo/cfa/cfa.cpp
%   → Cfa2Rgb_operator() 함수 (22~93행)
%   → cfa() 함수의 line_buffer/window 기반 3x3 윈도우 구성 (96~152행)
%
% [입력]
%   bayer_img - Bayer 패턴 이미지 (rows x cols, uint8 또는 double)
%               OV4689 센서의 원시(raw) 출력에 해당하는 단일 채널 영상
%               각 픽셀은 RGGB 패턴 중 하나의 색상값만 포함
%
% [출력]
%   rgb_img   - 디모자이킹된 RGB 컬러 이미지 (rows x cols x 3, uint8)
%               3개 채널 순서: R(1), G(2), B(3) — MATLAB 표준 순서
%
% [참고]
%   - FPGA cfa.cpp는 line_buffer[3][MAX_WIDTH+2]와 window[3][3]을
%     사용하여 스트리밍 방식으로 3x3 윈도우를 구성합니다.
%     이 MATLAB 코드는 동일한 결과를 padarray + 직접 인덱싱으로 구현합니다.
%   - FPGA 내부에서 행/열 오프셋(+2, border 처리)을 적용하므로,
%     이 MATLAB 코드의 padarray('replicate')가 동등한 경계 처리를 수행합니다.
%   - bilinear 보간은 가장 단순하지만 FPGA 자원 소모가 적은 방식으로,
%     별 추적기(Star Tracker)에서는 색상 정확도보다 연산 속도가 중요합니다.

% --- 입력 데이터를 double형으로 변환 ---
% uint8 입력의 경우 정수 나눗셈으로 인한 정밀도 손실을 방지하기 위해
% 보간 연산 전에 부동소수점(double)으로 변환합니다.
bayer_img = double(bayer_img);
[rows, cols] = size(bayer_img);

% --- 경계 패딩 (3x3 윈도우 처리를 위해 상하좌우 1픽셀씩 확장) ---
% 'replicate' 패딩을 사용하는 이유:
%   - 영상 가장자리 픽셀에서도 3x3 윈도우를 적용하려면 경계 밖에
%     가상의 픽셀이 필요합니다.
%   - 'replicate'는 가장자리 픽셀 값을 그대로 복사하여 확장하므로,
%     경계에서 부자연스러운 색상 왜곡(artifacts)을 최소화합니다.
%   - FPGA cfa.cpp에서는 line_buffer의 초기값과 border 영역 처리가
%     이와 유사한 효과를 냅니다. (row/col 오프셋 +2 적용)
%   - 다른 방식 비교:
%       'symmetric' (대칭 반사) → Bayer 패턴 규칙이 깨질 수 있음
%       'circular' (순환 반복) → 영상 반대편 값이 섞여 부적합
%       zero-padding (0으로 채움) → 경계가 어두워지는 문제 발생
padded = padarray(bayer_img, [1 1], 'replicate');

% --- 출력 RGB 채널별 버퍼 초기화 ---
% 각 채널을 개별 행렬로 생성한 후, 마지막에 cat()으로 합칩니다.
R = zeros(rows, cols);
G = zeros(rows, cols);
B = zeros(rows, cols);

% --- 모든 픽셀에 대해 3x3 윈도우 기반 보간 수행 ---
for row = 1:rows
    for col = 1:cols
        % padded 이미지에서의 인덱스 (원본 대비 +1 오프셋)
        pr = row + 1;
        pc = col + 1;
        % 현재 픽셀 중심의 3x3 윈도우 추출
        % w(1,1)=좌상단, w(2,2)=중심(현재 픽셀), w(3,3)=우하단
        w = padded(pr-1:pr+1, pc-1:pc+1);

        % Bayer 패턴에서 현재 픽셀의 위치 유형 판별
        % MATLAB은 1-based이므로 (row-1), (col-1)로 0-based 인덱스 계산
        r_idx = mod(row-1, 2);
        c_idx = mod(col-1, 2);
        % pos_idx: 2비트 값 (상위비트=행 홀짝, 하위비트=열 홀짝)
        % FPGA cfa.cpp의 ap_uint<2> pos_idx와 동일한 계산
        pos_idx = r_idx * 2 + c_idx;

        switch pos_idx
            % ===================================================================
            % case 0: R 위치 (짝수행, 짝수열)
            % -------------------------------------------------------------------
            % 현재 픽셀은 Red 값을 직접 가지고 있음 (센서에서 측정)
            % Green과 Blue는 주변 픽셀로부터 보간으로 복원
            %
            % 3x3 윈도우 배치도 (Bayer 패턴 기준):
            %
            %   +------+------+------+
            %   | B    | Gb   | B    |    w(1,1)  w(1,2)  w(1,3)
            %   | (1,1)| (1,2)| (1,3)|
            %   +------+------+------+
            %   | Gr   |[R]   | Gr   |    w(2,1) [w(2,2)] w(2,3)
            %   | (2,1)|(2,2) | (2,3)|    ← 현재 픽셀 (중심)
            %   +------+------+------+
            %   | B    | Gb   | B    |    w(3,1)  w(3,2)  w(3,3)
            %   | (3,1)| (3,2)| (3,3)|
            %   +------+------+------+
            %
            % R: 중심값 그대로 사용
            %      R = w(2,2) = [R]
            %
            % G: 상하좌우 4개 Green 이웃의 평균 (십자형 보간)
            %            Gb(1,2)
            %              |
            %      Gr(2,1)--[R]--Gr(2,3)
            %              |
            %            Gb(3,2)
            %      G = (w(1,2) + w(2,1) + w(2,3) + w(3,2)) / 4
            %
            % B: 대각선 4개 Blue 이웃의 평균 (X자형 보간)
            %      B(1,1)        B(1,3)
            %          \        /
            %           [R]
            %          /        \
            %      B(3,1)        B(3,3)
            %      B = (w(1,1) + w(1,3) + w(3,1) + w(3,3)) / 4
            % -------------------------------------------------------------------
            case 0  % R 위치
                R(row,col) = w(2,2);
                G(row,col) = (w(1,2) + w(2,1) + w(2,3) + w(3,2)) / 4;
                B(row,col) = (w(1,1) + w(1,3) + w(3,1) + w(3,3)) / 4;

            % ===================================================================
            % case 1: Gr 위치 (짝수행, 홀수열) — R 행에 있는 Green
            % -------------------------------------------------------------------
            % 현재 픽셀은 Green 값을 직접 가지고 있음
            % Red와 Blue는 주변 픽셀로부터 보간으로 복원
            %
            % 3x3 윈도우 배치도 (Bayer 패턴 기준):
            %
            %   +------+------+------+
            %   | Gb   | B    | Gb   |    w(1,1)  w(1,2)  w(1,3)
            %   | (1,1)| (1,2)| (1,3)|
            %   +------+------+------+
            %   | R    |[Gr]  | R    |    w(2,1) [w(2,2)] w(2,3)
            %   | (2,1)|(2,2) | (2,3)|    ← 현재 픽셀 (중심)
            %   +------+------+------+
            %   | Gb   | B    | Gb   |    w(3,1)  w(3,2)  w(3,3)
            %   | (3,1)| (3,2)| (3,3)|
            %   +------+------+------+
            %
            % R: 좌우 2개 Red 이웃의 평균 (수평 보간)
            %      R(2,1)--[Gr]--R(2,3)
            %      R = (w(2,1) + w(2,3)) / 2
            %
            % G: 중심값 그대로 사용
            %      G = w(2,2) = [Gr]
            %
            % B: 상하 2개 Blue 이웃의 평균 (수직 보간)
            %            B(1,2)
            %              |
            %           [Gr]
            %              |
            %            B(3,2)
            %      B = (w(1,2) + w(3,2)) / 2
            % -------------------------------------------------------------------
            case 1  % Gr 위치
                R(row,col) = (w(2,1) + w(2,3)) / 2;
                G(row,col) = w(2,2);
                B(row,col) = (w(1,2) + w(3,2)) / 2;

            % ===================================================================
            % case 2: Gb 위치 (홀수행, 짝수열) — B 행에 있는 Green
            % -------------------------------------------------------------------
            % 현재 픽셀은 Green 값을 직접 가지고 있음
            % Red와 Blue는 주변 픽셀로부터 보간으로 복원
            %
            % 3x3 윈도우 배치도 (Bayer 패턴 기준):
            %
            %   +------+------+------+
            %   | Gr   | R    | Gr   |    w(1,1)  w(1,2)  w(1,3)
            %   | (1,1)| (1,2)| (1,3)|
            %   +------+------+------+
            %   | B    |[Gb]  | B    |    w(2,1) [w(2,2)] w(2,3)
            %   | (2,1)|(2,2) | (2,3)|    ← 현재 픽셀 (중심)
            %   +------+------+------+
            %   | Gr   | R    | Gr   |    w(3,1)  w(3,2)  w(3,3)
            %   | (3,1)| (3,2)| (3,3)|
            %   +------+------+------+
            %
            % R: 상하 2개 Red 이웃의 평균 (수직 보간)
            %            R(1,2)
            %              |
            %           [Gb]
            %              |
            %            R(3,2)
            %      R = (w(1,2) + w(3,2)) / 2
            %
            % G: 중심값 그대로 사용
            %      G = w(2,2) = [Gb]
            %
            % B: 좌우 2개 Blue 이웃의 평균 (수평 보간)
            %      B(2,1)--[Gb]--B(2,3)
            %      B = (w(2,1) + w(2,3)) / 2
            % -------------------------------------------------------------------
            case 2  % Gb 위치
                R(row,col) = (w(1,2) + w(3,2)) / 2;
                G(row,col) = w(2,2);
                B(row,col) = (w(2,1) + w(2,3)) / 2;

            % ===================================================================
            % case 3: B 위치 (홀수행, 홀수열)
            % -------------------------------------------------------------------
            % 현재 픽셀은 Blue 값을 직접 가지고 있음
            % Red와 Green은 주변 픽셀로부터 보간으로 복원
            %
            % 3x3 윈도우 배치도 (Bayer 패턴 기준):
            %
            %   +------+------+------+
            %   | R    | Gr   | R    |    w(1,1)  w(1,2)  w(1,3)
            %   | (1,1)| (1,2)| (1,3)|
            %   +------+------+------+
            %   | Gb   |[B]   | Gb   |    w(2,1) [w(2,2)] w(2,3)
            %   | (2,1)|(2,2) | (2,3)|    ← 현재 픽셀 (중심)
            %   +------+------+------+
            %   | R    | Gr   | R    |    w(3,1)  w(3,2)  w(3,3)
            %   | (3,1)| (3,2)| (3,3)|
            %   +------+------+------+
            %
            % R: 대각선 4개 Red 이웃의 평균 (X자형 보간)
            %      R(1,1)        R(1,3)
            %          \        /
            %           [B]
            %          /        \
            %      R(3,1)        R(3,3)
            %      R = (w(1,1) + w(1,3) + w(3,1) + w(3,3)) / 4
            %
            % G: 상하좌우 4개 Green 이웃의 평균 (십자형 보간)
            %            Gr(1,2)
            %              |
            %      Gb(2,1)--[B]--Gb(2,3)
            %              |
            %            Gr(3,2)
            %      G = (w(1,2) + w(2,1) + w(2,3) + w(3,2)) / 4
            %
            % B: 중심값 그대로 사용
            %      B = w(2,2) = [B]
            % -------------------------------------------------------------------
            case 3  % B 위치
                R(row,col) = (w(1,1) + w(1,3) + w(3,1) + w(3,3)) / 4;
                G(row,col) = (w(1,2) + w(2,1) + w(2,3) + w(3,2)) / 4;
                B(row,col) = w(2,2);
        end
    end
end

% --- 8비트 ADC 범위 클램핑 (0~255) ---
% OV4689 이미지 센서의 ADC(아날로그-디지털 변환기)는 8비트 출력을 사용하므로
% 유효한 픽셀 값의 범위는 0(완전 어두움) ~ 255(완전 밝음)입니다.
% 보간 연산 결과가 이 범위를 벗어나지 않도록 클램핑합니다.
% (정상적인 경우 범위를 초과하지 않지만, 부동소수점 반올림 오차 등에 대비)
% FPGA cfa.cpp 대응 코드 (83~85행):
%   R = R > (u16)255 ? (u16)255 : R;
%   G = G > (u16)255 ? (u16)255 : G;
%   B = B > (u16)255 ? (u16)255 : B;
R = max(0, min(255, R));
G = max(0, min(255, G));
B = max(0, min(255, B));

% --- RGB 채널 결합 및 uint8 변환 ---
% [채널 순서 차이 주의]
%   MATLAB: cat(3, R, G, B) → 채널 순서 [R, G, B] (MATLAB 표준)
%     → rgb_img(:,:,1) = R, rgb_img(:,:,2) = G, rgb_img(:,:,3) = B
%
%   FPGA cfa.cpp (87~89행): pRst.val[0]=G, pRst.val[1]=B, pRst.val[2]=R
%     → 출력 채널 순서 [G, B, R] (AXI Stream 32비트 패킹 순서)
%     → 이는 후단 IP(rgb2gray 등)가 이 순서를 기대하기 때문
%
%   이 MATLAB 코드는 MATLAB 환경에서의 시각화/검증이 목적이므로
%   MATLAB 표준인 [R, G, B] 순서를 사용합니다.
%   FPGA 출력과 직접 비트 비교 시에는 채널 순서 변환이 필요합니다.
rgb_img = uint8(cat(3, R, G, B));
end
