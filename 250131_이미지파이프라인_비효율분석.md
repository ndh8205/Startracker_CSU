# 이미지 파이프라인 비효율 분석: CFA→RGB→Gray 불필요 경로 문제

> **상태**: 분석 완료, 해결 미완료
> **작성일**: 2026-01-31
> **관련 프로젝트**: GAiMSat-1 Star Tracker FPGA (Zynq-7015 + OV4689)

---

## 목차

1. [문제 요약 (비전문가 대상)](#1-문제-요약)
2. [현재 파이프라인 상세 분석](#2-현재-파이프라인-상세-분석)
3. [왜 비효율적인가?](#3-왜-비효율적인가)
4. [해결 방안](#4-해결-방안)
5. [MATLAB 시뮬레이션 검증 현황](#5-matlab-시뮬레이션-검증-현황)
6. [다음 단계 (TODO)](#6-다음-단계)
7. [관련 파일 목록](#7-관련-파일-목록)

---

## 1. 문제 요약

### 비전문가를 위한 설명

이 프로젝트의 Star Tracker(별 추적기)는 카메라로 밤하늘을 찍어서 별의 **위치(밝기 패턴)**만 파악하면 됩니다. 별의 **색깔은 전혀 필요 없습니다**.

그런데 현재 FPGA 파이프라인은 이렇게 동작합니다:

```
카메라 원본(흑백 비슷한 데이터)
    → [1단계] 힘들게 컬러(RGB) 이미지로 변환  ← 불필요한 작업!
    → [2단계] 다시 흑백으로 변환              ← 되돌리는 작업!
    → 별 검출 알고리즘에 전달
```

이것은 마치:

> **한국어 문장을 영어로 번역한 다음, 다시 한국어로 번역해서 사용하는 것**과 같습니다.
> 원본 한국어를 그대로 쓰면 되는데, 왜 굳이 영어로 갔다가 돌아올까요?

### 핵심 문제

| 문제 | 설명 |
|------|------|
| **리소스 낭비** | CFA IP가 3×1280바이트 라인버퍼 + 나눗셈 로직을 소비 |
| **레이턴시 증가** | 3×3 윈도우 연산으로 최소 2행(2560픽셀) 지연 |
| **전력 낭비** | 불필요한 로직이 200MHz로 동작하며 전력 소비 |
| **Centroid 왜곡 가능성** | CFA 보간이 인접 픽셀 값을 섞어서 별의 밝기 프로파일 변형 |

### 해결 방향

```
카메라 원본(흑백 비슷한 데이터)
    → 그대로 별 검출 알고리즘에 전달  ← 끝!
```

CFA와 rgb2gray IP를 **제거**하고, 센서 데이터를 **직접** 사용하면 됩니다.

---

## 2. 현재 파이프라인 상세 분석

### 2.1 전체 데이터 흐름도

```
OV4689 센서 (MIPI CSI-2, Raw Bayer 10-bit)
    │
    │  MIPI 고속 시리얼 데이터
    ▼
┌─────────────────────────────────┐
│  MIPI 수신부 (MIPI_0 + 정렬)    │  MIPI 디시리얼라이저
│  scan_sm_0 → mipi_align_0       │  프레임/라인 동기화
└──────────────┬──────────────────┘
               │  64-bit 패킹된 데이터 (AXI VDMA → FIFO)
               ▼
┌─────────────────────────────────┐
│  strm1x4  (HLS IP)              │  64-bit → 10-bit × 4 픽셀 언팩
│  소스: ip_repo/strm1x4/         │  II=4 (4클럭에 4픽셀 출력)
│  strm1x4.cpp                    │
└──────────────┬──────────────────┘
               │  10-bit 픽셀 스트림 (strmo[9:0])
               ▼
┌─────────────────────────────────┐
│  vstrm_adpt  (Verilog 조합로직)  │  상위 2비트 버림 + 제어신호 추출
│  소스: system.srcs/.../          │  od[7:0] = di[7:0]  (데이터)
│  vstrm_adpt.v                   │  user    = di[9]     (TUSER: 프레임 시작)
│                                 │  last    = di[8]     (TLAST: 라인 끝)
└──────────────┬──────────────────┘
               │  8-bit Bayer 데이터 + AXI Stream 제어신호
               │
               │  ★ 여기서 이미 8-bit 그레이스케일과 동일한 포맷!
               │
               ▼
┌═════════════════════════════════┐
║  cfa  (HLS IP) ← 제거 대상 1    ║  Bayer → RGB 디모자이킹
║  소스: ip_repo/cfa/cfa.cpp      ║  3×3 윈도우 bilinear 보간
║                                 ║  라인버퍼: 3 × 1282 bytes = 3.8KB
║  입력: AXI Stream 8-bit         ║
║  출력: AXI Stream 32-bit (RGB)  ║  ← 대역폭 4배 증가!
║  지연: 최소 2행 (2560 클럭)      ║
╚══════════════╦══════════════════╝
               │  32-bit RGB (val[0]=G, val[1]=B, val[2]=R)
               ▼
┌═════════════════════════════════┐
║  rgb2gray  (HLS IP) ← 제거 대상 2║  RGB → Grayscale
║  소스: ip_repo/rgb2gray/        ║  공식: (G + 2B + R) / 4
║  rgb2gray.cpp                   ║  (실제로는 GBR 순서)
║                                 ║
║  입력: AXI Stream 32-bit        ║
║  출력: AXI Stream 8-bit         ║  ← 다시 8-bit로 돌아옴!
╚══════════════╦══════════════════╝
               │  8-bit Grayscale
               ▼
┌─────────────────────────────────┐
│  ov4689_mem  (HLS IP)            │  DDR 순환 버퍼에 저장
│  소스: ip_repo/ov4689_mem/       │  8프레임 순환 (iFcnt & 0x7)
│  ov4689_mem.cpp                  │  M-AXI → DDR3 메모리
│                                 │
│  입력: AXI Stream 8-bit          │  ← vstrm_adpt 출력과 동일 포맷!
│  출력: DDR 메모리 (1280×720/프레임)│
└──────────────┬──────────────────┘
               │
               ▼
         ARM CPU (PS)
         별 검출 → Centroid → Star ID → Attitude
```

### 2.2 핵심 인터페이스 정리

```
                    데이터 폭     AXI Stream 타입
                    ─────────    ──────────────────
vstrm_adpt 출력:    8-bit        ap_axiu<8,1,1,1>에 대응
cfa 입력:           8-bit        ap_axiu<8,1,1,1>
cfa 출력:           32-bit       ap_axiu<32,1,1,1>  ← 4배로 불어남
rgb2gray 입력:      32-bit       ap_axiu<32,1,1,1>
rgb2gray 출력:      8-bit        ap_axiu<8,1,1,1>   ← 다시 줄어듦
ov4689_mem 입력:    8-bit        ap_axiu<8,1,1,1>
```

**결론: vstrm_adpt 출력과 ov4689_mem 입력이 동일한 8-bit AXI Stream입니다.**
CFA와 rgb2gray를 제거하면 인터페이스 변경 없이 직결 가능합니다.

### 2.3 CFA 알고리즘 상세

소스 파일: `ip_repo/cfa/cfa.cpp` (155줄)

#### 데이터 구조

```c
unsigned char line_buffer[3][MAX_WIDTH + 2];  // 3줄 히스토리 (3 × 1282 = 3846 bytes)
unsigned char window[3][3];                    // 3×3 슬라이딩 윈도우
```

#### Bayer RGGB 패턴에서의 보간 규칙

```
Bayer 2×2 블록 (OV4689는 RGGB):
  ┌────┬────┐
  │ R  │ Gr │   짝수 행
  ├────┼────┤
  │ Gb │ B  │   홀수 행
  └────┴────┘
  짝수열 홀수열
```

```
pos_idx = (row%2)*2 + (col%2)

pos 0 (R 위치, 짝수행 짝수열):
  R = window[1][1]                                         ← 자기 자신
  G = (window[0][1] + window[1][0] + window[1][2] + window[2][1]) / 4  ← 상하좌우 평균
  B = (window[0][0] + window[0][2] + window[2][0] + window[2][2]) / 4  ← 대각선 평균

pos 1 (Gr 위치, 짝수행 홀수열):
  R = (window[1][0] + window[1][2]) / 2                    ← 좌우 평균
  G = window[1][1]                                         ← 자기 자신
  B = (window[0][1] + window[2][1]) / 2                    ← 상하 평균

pos 2 (Gb 위치, 홀수행 짝수열):
  R = (window[0][1] + window[2][1]) / 2                    ← 상하 평균
  G = window[1][1]                                         ← 자기 자신
  B = (window[1][0] + window[1][2]) / 2                    ← 좌우 평균

pos 3 (B 위치, 홀수행 홀수열):
  R = (window[0][0] + window[0][2] + window[2][0] + window[2][2]) / 4  ← 대각선 평균
  G = (window[0][1] + window[1][0] + window[1][2] + window[2][1]) / 4  ← 상하좌우 평균
  B = window[1][1]                                         ← 자기 자신
```

#### 출력 순서 (주의)

```c
pRst.val[0] = G;   // 채널 0 = Green
pRst.val[1] = B;   // 채널 1 = Blue
pRst.val[2] = R;   // 채널 2 = Red
```

출력이 **GBR 순서**입니다 (일반적인 RGB가 아님). 이것이 rgb2gray에서의 가중치 해석에 영향을 줍니다.

#### HLS 최적화 프라그마

```c
#pragma HLS dataflow              // 파이프라인 병렬 실행
#pragma HLS loop_flatten off      // 루프 계층 유지
#pragma HLS pipeline II=1         // 1클럭에 1픽셀 처리
```

### 2.4 rgb2gray 알고리즘 상세

소스 파일: `ip_repo/rgb2gray/rgb2gray.cpp` (53줄)

#### 핵심 연산 (1줄)

```c
pOut.val[0] = (p.val[0] + p.val[1] + p.val[1] + p.val[2]) / 4;
```

CFA의 출력 순서가 GBR이므로:
- `p.val[0]` = G (Green)
- `p.val[1]` = B (Blue) → **2배 가중**
- `p.val[2]` = R (Red)

실제 공식: **Gray = (G + 2B + R) / 4**

이것은 일반적인 ITU-R BT.601 표준 `Y = 0.299R + 0.587G + 0.114B`와 상당히 다릅니다:

| 채널 | 표준 가중치 | FPGA 가중치 | 차이 |
|------|-----------|------------|------|
| R | 0.299 | 0.25 | -16% |
| G | 0.587 | 0.25 | **-57%** |
| B | 0.114 | 0.50 | **+339%** |

**FPGA 구현이 Blue를 과도하게 가중하고 있습니다.** 이는 CFA 출력의 채널 순서(GBR)를 RGB로 잘못 인식했을 가능성이 있습니다. 만약 의도가 `(R + 2G + B) / 4`였다면 `val[1]`이 G여야 하는데, 실제로는 B입니다.

> **참고**: 별 추적에서는 이 가중치 오류가 큰 문제가 되지 않습니다. 어차피 최종 결과는 밝기 값이고, 별은 백색광에 가깝기 때문입니다. 하지만 이것은 현재 파이프라인에 숨겨진 버그일 수 있습니다.

---

## 3. 왜 비효율적인가?

### 3.1 별 추적에 색 정보가 불필요한 이유

별 추적기의 작업 순서:

```
1. 이미지에서 밝은 점(별) 찾기          → 밝기만 필요
2. 각 별의 정확한 중심 좌표 계산         → 밝기 프로파일만 필요
3. 별 패턴을 카탈로그와 매칭            → 별 간 각도만 필요
4. 위성 자세(방향) 계산                → 좌표만 필요
```

**어떤 단계에서도 색(R, G, B) 정보는 사용하지 않습니다.**

### 3.2 CFA 보간이 Centroid에 미치는 악영향

CFA 디모자이킹은 3×3 이웃 픽셀의 평균을 계산합니다. 이 과정에서:

```
원본 별 PSF (Point Spread Function):
  0   0   0   0   0
  0   5  30   5   0      ← 날카로운 피크
  0  30 255  30   0
  0   5  30   5   0
  0   0   0   0   0

CFA 보간 후:
  0   2   3   2   0
  2  15  28  15   2      ← 피크가 줄고 퍼짐
  3  28 200  28   3
  2  15  28  15   2
  0   2   3   2   0
```

**보간이 별의 밝기 프로파일을 인위적으로 퍼뜨립니다(smoothing).** 이는:
- 피크 밝기 감소 → 어두운 별 검출률 저하
- PSF 형태 변형 → Centroid 정확도 저하 가능
- Bayer 패턴 위치에 따른 비대칭 보간 → 시스템 오차 도입

### 3.3 리소스 낭비 정량 분석

| 항목 | CFA | rgb2gray | 합계 |
|------|-----|----------|------|
| BRAM (라인버퍼) | 3 × 1282 = 3.8 KB | 0 | **3.8 KB** |
| LUT (로직) | ~200 (보간, 나눗셈) | ~50 (가중 평균) | **~250** |
| FF (레지스터) | ~150 (윈도우, 제어) | ~30 | **~180** |
| DSP | 0 (정수 나눗셈) | 0 | 0 |
| 레이턴시 | 2행 + α | 0 | **2행 (~2560 클럭)** |
| 대역폭 | 8-bit→32-bit (4배) | 32-bit→8-bit | 중간 32-bit 낭비 |

Zynq-7015의 리소스:
- 총 BRAM: 95 블록 (36Kb 각) = 약 427.5 KB
- 총 LUT: 46,200개
- CFA+rgb2gray 사용량: BRAM 약 1%, LUT 약 0.5%

> 비율로는 작지만, 전력 측면에서는 200MHz로 매 클럭마다 불필요한 연산을 수행하는 것이므로 절감 효과가 있습니다.

### 3.4 인터페이스 호환성 (핵심 발견)

```
vstrm_adpt 출력:    8-bit + TUSER + TLAST   ───┐
                                                │ 동일한 포맷!
ov4689_mem 입력:    8-bit AXI Stream          ───┘
                    (ap_axiu<8,1,1,1>)
```

vstrm_adpt에서 나오는 8-bit 데이터는 Bayer 패턴의 raw 값입니다.
ov4689_mem은 8-bit AXI Stream을 받아서 DDR에 저장합니다.

**CFA와 rgb2gray를 제거하고 직결해도 인터페이스가 완벽히 호환됩니다.**

---

## 4. 해결 방안

### 방안 A: 패스스루 (CFA + rgb2gray 제거, Block Design 직결)

```
현재:  vstrm_adpt → [cfa] → [rgb2gray] → ov4689_mem
수정:  vstrm_adpt ─────────────────────→ ov4689_mem
```

| 항목 | 내용 |
|------|------|
| **수정 범위** | Block Design (system.bd) 연결만 변경 |
| **소스코드 변경** | 없음 (기존 IP 유지, 연결만 우회) |
| **수정 방법** | Vivado GUI에서 cfa_0, rgb2gray_0 삭제 후 재연결 또는 TCL 스크립트 |
| **장점** | 가장 간단, 리소스 즉시 회수, 레이턴시 최소화 |
| **단점** | Bayer 격자 패턴이 그대로 남음 (R/G/B 감도 차이) |
| **HDMI 영향** | 디스플레이 경로 별도 확인 필요 (gray2RGB_0가 CFA 출력을 사용하는 경우) |

**TCL 스크립트 예시** (Vivado에서 `source` 명령으로 실행):

```tcl
# Block Design 열기
open_bd_design [get_files system.bd]

# 기존 연결 삭제
delete_bd_objs [get_bd_intf_nets cfa_0_video_out]
delete_bd_objs [get_bd_intf_nets rgb2gray_0_video_out]

# vstrm_adpt 출력 → ov4689_mem 입력 직결
# (실제 신호명은 Block Design 확인 후 조정 필요)
connect_bd_intf_net [get_bd_intf_pins vstrm_adpt_0/...] \
                    [get_bd_intf_pins ov4689_mem_0/VIDEO_IN]

# IP 삭제 (선택사항)
delete_bd_objs [get_bd_cells cfa_0]
delete_bd_objs [get_bd_cells rgb2gray_0]

# 검증
validate_bd_design
save_bd_design
```

> 주의: vstrm_adpt는 AXI Stream 포트가 아닌 개별 와이어(od, user, last)를 출력하므로,
> CFA에 연결되던 AXI Stream 래퍼 로직을 ov4689_mem에 연결해야 합니다.
> Block Design을 열어서 정확한 연결 구조를 확인해야 합니다.

### 방안 B: 단일 bayer2gray HLS IP 신규 작성

```
현재:  vstrm_adpt → [cfa] → [rgb2gray]     → ov4689_mem
수정:  vstrm_adpt → [bayer2gray (신규 IP)]  → ov4689_mem
```

| 항목 | 내용 |
|------|------|
| **수정 범위** | 새 HLS IP 작성 + Block Design 수정 |
| **소스코드 변경** | `ip_repo/bayer2gray/bayer2gray.cpp` 신규 작성 |
| **장점** | Bayer 격자 패턴 제거 가능, 품질 향상 옵션 |
| **단점** | 새 IP 개발 + 검증 필요 |

**구현 옵션**:

| 옵션 | 알고리즘 | 출력 해상도 | 리소스 |
|------|---------|-----------|--------|
| B1. RAW | 그대로 통과 | 1280×720 | 거의 0 |
| B2. 2×2 Binning | (R+Gr+Gb+B)/4 | 640×360 | 라인버퍼 1줄 + 덧셈/시프트 |
| B3. Green 추출 | G는 그대로, R/B 위치는 G 보간 | 1280×720 | 라인버퍼 1줄 |
| B4. 가중 평균 | 위치별 (R+2G+B)/4 | 1280×720 | 라인버퍼 3줄 (CFA와 유사) |

**B1(RAW) HLS IP 코드 골격**:

```cpp
#include "hls_video.h"

#define MAX_WIDTH  1280
#define MAX_HEIGHT 720

typedef hls::stream<ap_axiu<8,1,1,1>> AXI_STREAM;
typedef hls::Mat<MAX_HEIGHT, MAX_WIDTH, HLS_8UC1> GRAY_IMAGE;

void bayer2gray(AXI_STREAM& video_in, AXI_STREAM& video_out)
{
#pragma HLS INTERFACE axis port=video_in bundle=INPUT_STREAM
#pragma HLS INTERFACE axis port=video_out bundle=OUTPUT_STREAM

    int rows = MAX_HEIGHT;
    int cols = MAX_WIDTH;
    GRAY_IMAGE _src(rows, cols);
    GRAY_IMAGE _dst(rows, cols);

#pragma HLS dataflow
    hls::AXIvideo2Mat(video_in, _src);

    // RAW 패스스루: 입력을 그대로 출력
    row_main:for(int row = 0; row < rows; row++) {
#pragma HLS loop_flatten off
        col_main:for(int col = 0; col < cols; col++) {
#pragma HLS pipeline II=1
            hls::Scalar<1, unsigned char> p;
            _src >> p;
            _dst << p;
        }
    }

    hls::Mat2AXIvideo(_dst, video_out);
}
```

### 방안 C: CFA 내부를 직접 gray 출력으로 수정

```
현재:  vstrm_adpt → [cfa (Bayer→RGB)] → [rgb2gray] → ov4689_mem
수정:  vstrm_adpt → [cfa (Bayer→Gray로 수정)] ────→ ov4689_mem
```

| 항목 | 내용 |
|------|------|
| **수정 범위** | cfa.cpp 수정 + Block Design 출력 포맷 변경 |
| **소스코드 변경** | cfa.cpp의 출력을 32-bit RGB → 8-bit Gray로 변경 |
| **장점** | 기존 라인버퍼/윈도우 인프라 재활용 가능, rgb2gray만 제거 |
| **단점** | CFA 입출력 인터페이스 변경 → Block Design도 수정 필요 |
| **적용 대상** | 방안 B4(가중 평균)를 기존 CFA 위에 구현할 때 유리 |

### 방안 비교 요약

| 기준 | 방안 A (패스스루) | 방안 B (신규 IP) | 방안 C (CFA 수정) |
|------|-----------------|-----------------|------------------|
| 구현 난이도 | 쉬움 | 보통 | 보통 |
| 수정 파일 수 | 0 (BD만) | 1 (신규 IP) + BD | 1 (cfa.cpp) + BD |
| Bayer 격자 제거 | X | O (B2~B4) | O |
| 리소스 절감 | 최대 | IP에 따라 다름 | CFA 유사 |
| 레이턴시 절감 | 최대 | IP에 따라 다름 | rgb2gray 분만큼 |
| MATLAB 검증 | 필요 | 필요 | 필요 |

### 권장 순서

```
1단계: MATLAB 시뮬레이션으로 RAW vs FPGA 성능 정량 비교
       → RAW로 충분하면 방안 A 채택
       → Bayer 격자가 문제되면 방안 B (2×2 Binning 또는 Green 추출) 채택

2단계: Block Design 수정 (TCL 스크립트 또는 Vivado GUI)
       → HDMI 디스플레이 경로 확인 후 처리

3단계: FPGA 합성 및 실기 검증
```

---

## 5. MATLAB 시뮬레이션 검증 현황

### 5.1 구현 완료된 시뮬레이션

`simulation/bayer_comparison/` 폴더에 다음 코드가 구현되어 있습니다:

| 파일 | 역할 |
|------|------|
| `main_simulation.m` | Hipparcos 카탈로그 기반 별 이미지 생성 |
| `sub_main_1_bayer_comparison.m` | 5가지 변환 방식 성능 비교 |
| `core/bayer_to_rgb_cfa.m` | FPGA CFA 재현 (MATLAB) |
| `core/rgb_to_gray_fpga.m` | FPGA rgb2gray 재현 (MATLAB) |
| `core/bayer_to_gray_direct.m` | 직접 변환 4가지 방법 |

### 5.2 비교 대상 5가지 방법

| 방법 | 설명 | FPGA 대응 |
|------|------|-----------|
| A. FPGA | Bayer → CFA → RGB → Gray | 현재 파이프라인 |
| B1. RAW | Bayer 값 그대로 사용 | 방안 A (패스스루) |
| B2. Binning | 2×2 블록 평균, 해상도 절반 | 방안 B (B2) |
| B3. Green | Green 채널 추출 + 보간 | 방안 B (B3) |
| B4. Weighted | 위치별 가중 평균 | 방안 B (B4) / 방안 C |

### 5.3 비교 메트릭

| 메트릭 | 함수 | 의미 |
|--------|------|------|
| Peak SNR | `calculate_peak_snr.m` | 가장 밝은 별 vs 배경 노이즈 (dB) |
| 별 검출 수 | `detect_stars_simple.m` | threshold+CCL로 검출된 별 개수 |
| Centroid RMS 오차 | `evaluate_centroid_accuracy.m` | 검출 위치 vs 실제 위치 오차 (pixel) |
| 처리 시간 | `tic/toc` | MATLAB 실행 시간 (ms) |

### 5.4 현재 결론 (정성적)

시뮬레이션 코드가 작성되어 있으나, **정량적 결과는 아직 확보하지 못했습니다.**
코드 구조와 알고리즘 분석에 기반한 정성적 예측:

| 방법 | Peak SNR | 검출률 | Centroid 정확도 | 처리 시간 |
|------|----------|--------|----------------|-----------|
| A. FPGA | 기준 | 기준 | 기준 | 기준 |
| B1. RAW | 동등~약간↓ | 동등 | 동등~약간↑ | 최소 |
| B2. Binning | ↑ (6dB) | ↑ | ↓ (해상도 절반) | 빠름 |
| B3. Green | 동등 | 동등 | 동등 | 빠름 |
| B4. Weighted | 동등 | 동등 | 동등 | 보통 |

> **핵심 예측**: RAW 직접 변환(B1)이 FPGA 방식(A)과 동등하거나 더 나은 성능을 보일 것으로 예상됩니다.
> 이유: CFA 보간이 PSF를 인위적으로 퍼뜨리므로, 보간하지 않는 RAW가 원본에 더 가깝습니다.

---

## 6. 다음 단계

- [ ] **MATLAB 시뮬레이션 실행**: `sub_main_1_bayer_comparison.m` 돌려서 정량적 결과 확보
- [ ] **결과 분석**: 어떤 방법이 최적인지 데이터 기반 결정
- [ ] **방안 결정**: 패스스루(A) vs 신규 IP(B) vs CFA 수정(C)
- [ ] **Block Design 확인**: HDMI 디스플레이 경로가 CFA 출력을 사용하는지 확인
- [ ] **구현**: 선택된 방안 적용
- [ ] **실기 검증**: FPGA 합성 후 실제 별 이미지로 검증
- [ ] 이 문서 제목에 "(완료됨)" 추가

---

## 7. 관련 파일 목록

### FPGA 소스코드 (수정/제거 대상)

| 파일 | 경로 | 역할 |
|------|------|------|
| cfa.cpp | `reverse_engineering/recent/ssov_v700_20260128_ljc/ip_repo/cfa/cfa.cpp` | Bayer→RGB (제거 대상) |
| rgb2gray.cpp | `reverse_engineering/recent/ssov_v700_20260128_ljc/ip_repo/rgb2gray/rgb2gray.cpp` | RGB→Gray (제거 대상) |
| ov4689_mem.cpp | `reverse_engineering/recent/ssov_v700_20260128_ljc/ip_repo/ov4689_mem/ov4689_mem.cpp` | DDR 저장 (유지) |
| vstrm_adpt.v | `reverse_engineering/recent/ssov_v700_20260128_ljc/system/system.srcs/sources_1/new/vstrm_adpt.v` | 10-bit→8-bit (유지) |
| strm1x4.cpp | `reverse_engineering/recent/ssov_v700_20260128_ljc/ip_repo/strm1x4/strm1x4.cpp` | 64-bit→10-bit (유지) |
| system.bd | `reverse_engineering/recent/ssov_v700_20260128_ljc/system/system.srcs/sources_1/bd/system/system.bd` | Block Design (수정 대상) |

### MATLAB 시뮬레이션 (검증용)

| 파일 | 경로 | 역할 |
|------|------|------|
| main_simulation.m | `simulation/bayer_comparison/main_simulation.m` | 별 이미지 생성 |
| sub_main_1_bayer_comparison.m | `simulation/bayer_comparison/sub_main_1_bayer_comparison.m` | 변환 방식 비교 |
| bayer_to_rgb_cfa.m | `simulation/bayer_comparison/core/bayer_to_rgb_cfa.m` | FPGA CFA 재현 |
| rgb_to_gray_fpga.m | `simulation/bayer_comparison/core/rgb_to_gray_fpga.m` | FPGA rgb2gray 재현 |
| bayer_to_gray_direct.m | `simulation/bayer_comparison/core/bayer_to_gray_direct.m` | 직접 변환 4가지 |

### 알고리즘 코드 (참고)

| 파일 | 경로 | 역할 |
|------|------|------|
| my_star_id.c | `reverse_engineering/recent/.../system.sdk/ssov/src/algorithm/my_star_id.c` | Pyramid 별 식별 |
| globalV.h | `reverse_engineering/recent/.../system.sdk/ssov/src/algorithm/globalV.h` | CCL 구조체 |

---

*최종 업데이트: 2026-01-31*
